// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shopproduct.proto

package go_micro_service_shop_product

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ProductInfo struct {
	Id                 int64           `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ProductName        string          `protobuf:"bytes,2,opt,name=product_name,json=productName,proto3" json:"product_name,omitempty"`
	ProductSku         string          `protobuf:"bytes,3,opt,name=product_sku,json=productSku,proto3" json:"product_sku,omitempty"`
	ProductPrice       float64         `protobuf:"fixed64,4,opt,name=product_price,json=productPrice,proto3" json:"product_price,omitempty"`
	ProductDescription string          `protobuf:"bytes,5,opt,name=product_description,json=productDescription,proto3" json:"product_description,omitempty"`
	ProductCategoryId  int64           `protobuf:"varint,6,opt,name=product_category_id,json=productCategoryId,proto3" json:"product_category_id,omitempty"`
	ProductImage       []*ProductImage `protobuf:"bytes,7,rep,name=product_image,json=productImage,proto3" json:"product_image,omitempty"`
	// 商品的尺寸
	ProductSize []*ProductSize `protobuf:"bytes,8,rep,name=product_size,json=productSize,proto3" json:"product_size,omitempty"`
	// 搜索引擎优化的展示的信息
	ProductSeo           *ProductSeo `protobuf:"bytes,9,opt,name=product_seo,json=productSeo,proto3" json:"product_seo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ProductInfo) Reset()         { *m = ProductInfo{} }
func (m *ProductInfo) String() string { return proto.CompactTextString(m) }
func (*ProductInfo) ProtoMessage()    {}
func (*ProductInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_40e4e27db916b118, []int{0}
}
func (m *ProductInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductInfo.Merge(m, src)
}
func (m *ProductInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProductInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProductInfo proto.InternalMessageInfo

func (m *ProductInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ProductInfo) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *ProductInfo) GetProductSku() string {
	if m != nil {
		return m.ProductSku
	}
	return ""
}

func (m *ProductInfo) GetProductPrice() float64 {
	if m != nil {
		return m.ProductPrice
	}
	return 0
}

func (m *ProductInfo) GetProductDescription() string {
	if m != nil {
		return m.ProductDescription
	}
	return ""
}

func (m *ProductInfo) GetProductCategoryId() int64 {
	if m != nil {
		return m.ProductCategoryId
	}
	return 0
}

func (m *ProductInfo) GetProductImage() []*ProductImage {
	if m != nil {
		return m.ProductImage
	}
	return nil
}

func (m *ProductInfo) GetProductSize() []*ProductSize {
	if m != nil {
		return m.ProductSize
	}
	return nil
}

func (m *ProductInfo) GetProductSeo() *ProductSeo {
	if m != nil {
		return m.ProductSeo
	}
	return nil
}

type ProductImage struct {
	Id        int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ImageName string `protobuf:"bytes,2,opt,name=image_name,json=imageName,proto3" json:"image_name,omitempty"`
	// 保证插入数据的幂等性
	ImageCode            string   `protobuf:"bytes,3,opt,name=image_code,json=imageCode,proto3" json:"image_code,omitempty"`
	ImageUrl             string   `protobuf:"bytes,4,opt,name=image_url,json=imageUrl,proto3" json:"image_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProductImage) Reset()         { *m = ProductImage{} }
func (m *ProductImage) String() string { return proto.CompactTextString(m) }
func (*ProductImage) ProtoMessage()    {}
func (*ProductImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_40e4e27db916b118, []int{1}
}
func (m *ProductImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductImage.Merge(m, src)
}
func (m *ProductImage) XXX_Size() int {
	return m.Size()
}
func (m *ProductImage) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductImage.DiscardUnknown(m)
}

var xxx_messageInfo_ProductImage proto.InternalMessageInfo

func (m *ProductImage) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ProductImage) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

func (m *ProductImage) GetImageCode() string {
	if m != nil {
		return m.ImageCode
	}
	return ""
}

func (m *ProductImage) GetImageUrl() string {
	if m != nil {
		return m.ImageUrl
	}
	return ""
}

type ProductSize struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SizeName             string   `protobuf:"bytes,2,opt,name=size_name,json=sizeName,proto3" json:"size_name,omitempty"`
	SizeCode             string   `protobuf:"bytes,3,opt,name=size_code,json=sizeCode,proto3" json:"size_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProductSize) Reset()         { *m = ProductSize{} }
func (m *ProductSize) String() string { return proto.CompactTextString(m) }
func (*ProductSize) ProtoMessage()    {}
func (*ProductSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_40e4e27db916b118, []int{2}
}
func (m *ProductSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductSize.Merge(m, src)
}
func (m *ProductSize) XXX_Size() int {
	return m.Size()
}
func (m *ProductSize) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductSize.DiscardUnknown(m)
}

var xxx_messageInfo_ProductSize proto.InternalMessageInfo

func (m *ProductSize) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ProductSize) GetSizeName() string {
	if m != nil {
		return m.SizeName
	}
	return ""
}

func (m *ProductSize) GetSizeCode() string {
	if m != nil {
		return m.SizeCode
	}
	return ""
}

type ProductSeo struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SeoTitle             string   `protobuf:"bytes,2,opt,name=seo_title,json=seoTitle,proto3" json:"seo_title,omitempty"`
	SeoKeywords          string   `protobuf:"bytes,3,opt,name=seo_keywords,json=seoKeywords,proto3" json:"seo_keywords,omitempty"`
	SeoDescription       string   `protobuf:"bytes,4,opt,name=seo_description,json=seoDescription,proto3" json:"seo_description,omitempty"`
	SeoCode              string   `protobuf:"bytes,6,opt,name=seo_code,json=seoCode,proto3" json:"seo_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProductSeo) Reset()         { *m = ProductSeo{} }
func (m *ProductSeo) String() string { return proto.CompactTextString(m) }
func (*ProductSeo) ProtoMessage()    {}
func (*ProductSeo) Descriptor() ([]byte, []int) {
	return fileDescriptor_40e4e27db916b118, []int{3}
}
func (m *ProductSeo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProductSeo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProductSeo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProductSeo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProductSeo.Merge(m, src)
}
func (m *ProductSeo) XXX_Size() int {
	return m.Size()
}
func (m *ProductSeo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProductSeo.DiscardUnknown(m)
}

var xxx_messageInfo_ProductSeo proto.InternalMessageInfo

func (m *ProductSeo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ProductSeo) GetSeoTitle() string {
	if m != nil {
		return m.SeoTitle
	}
	return ""
}

func (m *ProductSeo) GetSeoKeywords() string {
	if m != nil {
		return m.SeoKeywords
	}
	return ""
}

func (m *ProductSeo) GetSeoDescription() string {
	if m != nil {
		return m.SeoDescription
	}
	return ""
}

func (m *ProductSeo) GetSeoCode() string {
	if m != nil {
		return m.SeoCode
	}
	return ""
}

type ResponseProduct struct {
	ProductId            int64    `protobuf:"varint,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseProduct) Reset()         { *m = ResponseProduct{} }
func (m *ResponseProduct) String() string { return proto.CompactTextString(m) }
func (*ResponseProduct) ProtoMessage()    {}
func (*ResponseProduct) Descriptor() ([]byte, []int) {
	return fileDescriptor_40e4e27db916b118, []int{4}
}
func (m *ResponseProduct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseProduct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseProduct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseProduct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseProduct.Merge(m, src)
}
func (m *ResponseProduct) XXX_Size() int {
	return m.Size()
}
func (m *ResponseProduct) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseProduct.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseProduct proto.InternalMessageInfo

func (m *ResponseProduct) GetProductId() int64 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

type RequestID struct {
	ProductId            int64    `protobuf:"varint,1,opt,name=product_id,json=productId,proto3" json:"product_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestID) Reset()         { *m = RequestID{} }
func (m *RequestID) String() string { return proto.CompactTextString(m) }
func (*RequestID) ProtoMessage()    {}
func (*RequestID) Descriptor() ([]byte, []int) {
	return fileDescriptor_40e4e27db916b118, []int{5}
}
func (m *RequestID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestID.Merge(m, src)
}
func (m *RequestID) XXX_Size() int {
	return m.Size()
}
func (m *RequestID) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestID.DiscardUnknown(m)
}

var xxx_messageInfo_RequestID proto.InternalMessageInfo

func (m *RequestID) GetProductId() int64 {
	if m != nil {
		return m.ProductId
	}
	return 0
}

type Response struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_40e4e27db916b118, []int{6}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type RequestAll struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestAll) Reset()         { *m = RequestAll{} }
func (m *RequestAll) String() string { return proto.CompactTextString(m) }
func (*RequestAll) ProtoMessage()    {}
func (*RequestAll) Descriptor() ([]byte, []int) {
	return fileDescriptor_40e4e27db916b118, []int{7}
}
func (m *RequestAll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestAll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestAll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestAll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestAll.Merge(m, src)
}
func (m *RequestAll) XXX_Size() int {
	return m.Size()
}
func (m *RequestAll) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestAll.DiscardUnknown(m)
}

var xxx_messageInfo_RequestAll proto.InternalMessageInfo

type AllProduct struct {
	ProductInfo          []*ProductInfo `protobuf:"bytes,1,rep,name=product_info,json=productInfo,proto3" json:"product_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AllProduct) Reset()         { *m = AllProduct{} }
func (m *AllProduct) String() string { return proto.CompactTextString(m) }
func (*AllProduct) ProtoMessage()    {}
func (*AllProduct) Descriptor() ([]byte, []int) {
	return fileDescriptor_40e4e27db916b118, []int{8}
}
func (m *AllProduct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllProduct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllProduct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllProduct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllProduct.Merge(m, src)
}
func (m *AllProduct) XXX_Size() int {
	return m.Size()
}
func (m *AllProduct) XXX_DiscardUnknown() {
	xxx_messageInfo_AllProduct.DiscardUnknown(m)
}

var xxx_messageInfo_AllProduct proto.InternalMessageInfo

func (m *AllProduct) GetProductInfo() []*ProductInfo {
	if m != nil {
		return m.ProductInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*ProductInfo)(nil), "go.micro.service.shop.product.ProductInfo")
	proto.RegisterType((*ProductImage)(nil), "go.micro.service.shop.product.ProductImage")
	proto.RegisterType((*ProductSize)(nil), "go.micro.service.shop.product.ProductSize")
	proto.RegisterType((*ProductSeo)(nil), "go.micro.service.shop.product.ProductSeo")
	proto.RegisterType((*ResponseProduct)(nil), "go.micro.service.shop.product.ResponseProduct")
	proto.RegisterType((*RequestID)(nil), "go.micro.service.shop.product.RequestID")
	proto.RegisterType((*Response)(nil), "go.micro.service.shop.product.Response")
	proto.RegisterType((*RequestAll)(nil), "go.micro.service.shop.product.RequestAll")
	proto.RegisterType((*AllProduct)(nil), "go.micro.service.shop.product.AllProduct")
}

func init() { proto.RegisterFile("shopproduct.proto", fileDescriptor_40e4e27db916b118) }

var fileDescriptor_40e4e27db916b118 = []byte{
	// 629 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0x8e, 0x9b, 0xfe, 0xda, 0x78, 0xdc, 0xbf, 0xfb, 0xbb, 0x98, 0x96, 0x86, 0x60, 0x0e, 0x75,
	0x8b, 0x64, 0x50, 0x79, 0x82, 0xb4, 0x11, 0x52, 0x40, 0xa0, 0xca, 0xa5, 0xe2, 0xc0, 0x21, 0x0a,
	0xde, 0x69, 0xba, 0xc4, 0xf1, 0x1a, 0xaf, 0x03, 0x4a, 0x9f, 0x84, 0x63, 0x1f, 0x87, 0x23, 0x07,
	0x1e, 0x00, 0x85, 0x17, 0x41, 0xbb, 0xd9, 0xb5, 0xad, 0x82, 0x48, 0xc2, 0xcd, 0x33, 0xf3, 0xed,
	0x37, 0x33, 0xdf, 0x7c, 0x4a, 0x60, 0x57, 0x5c, 0xf3, 0x34, 0xcd, 0x38, 0x1d, 0x47, 0x79, 0x90,
	0x66, 0x3c, 0xe7, 0xe4, 0x60, 0xc0, 0x83, 0x11, 0x8b, 0x32, 0x1e, 0x08, 0xcc, 0x3e, 0xb1, 0x08,
	0x03, 0x89, 0x09, 0x34, 0xc8, 0xfb, 0x5e, 0x07, 0xe7, 0x7c, 0xf6, 0xdd, 0x4d, 0xae, 0x38, 0xd9,
	0x82, 0x15, 0x46, 0x5d, 0xab, 0x65, 0xf9, 0xf5, 0x70, 0x85, 0x51, 0xf2, 0x10, 0x36, 0x34, 0xb4,
	0x97, 0xf4, 0x47, 0xe8, 0xae, 0xb4, 0x2c, 0xdf, 0x0e, 0x1d, 0x9d, 0x7b, 0xdd, 0x1f, 0x21, 0x79,
	0x00, 0x26, 0xec, 0x89, 0xe1, 0xd8, 0xad, 0x2b, 0x04, 0xe8, 0xd4, 0xc5, 0x70, 0x4c, 0x1e, 0xc1,
	0xa6, 0x01, 0xa4, 0x19, 0x8b, 0xd0, 0x5d, 0x6d, 0x59, 0xbe, 0x15, 0x1a, 0xe2, 0x73, 0x99, 0x23,
	0x4f, 0xe0, 0x7f, 0x03, 0xa2, 0x28, 0xa2, 0x8c, 0xa5, 0x39, 0xe3, 0x89, 0xfb, 0x9f, 0x62, 0x23,
	0xba, 0xd4, 0x29, 0x2b, 0x24, 0x28, 0x1f, 0x44, 0xfd, 0x1c, 0x07, 0x3c, 0x9b, 0xf4, 0x18, 0x75,
	0xd7, 0xd4, 0xe8, 0xbb, 0xba, 0x74, 0xa6, 0x2b, 0x5d, 0x4a, 0xce, 0xcb, 0x29, 0xd8, 0xa8, 0x3f,
	0x40, 0x77, 0xbd, 0x55, 0xf7, 0x9d, 0x93, 0xc7, 0xc1, 0x5f, 0x05, 0x0a, 0x8c, 0x38, 0xf2, 0x49,
	0x31, 0xb2, 0x8a, 0xc8, 0xab, 0x52, 0x1b, 0xc1, 0x6e, 0xd0, 0x6d, 0x28, 0xc2, 0xe3, 0xc5, 0x08,
	0x2f, 0xd8, 0x0d, 0x16, 0x3a, 0xca, 0x80, 0xbc, 0xa8, 0xe8, 0x88, 0xdc, 0xb5, 0x5b, 0x96, 0xef,
	0x9c, 0x1c, 0x2d, 0xc8, 0x86, 0xbc, 0x94, 0x1c, 0xb9, 0x37, 0x81, 0x8d, 0xea, 0xe0, 0xbf, 0x9d,
	0xf5, 0x00, 0x40, 0x89, 0x50, 0x3d, 0xaa, 0xad, 0x32, 0xea, 0xa4, 0x45, 0x39, 0xe2, 0x14, 0xf5,
	0x45, 0x67, 0xe5, 0x33, 0x4e, 0x91, 0xec, 0xc3, 0x2c, 0xe8, 0x8d, 0xb3, 0x58, 0x1d, 0xd3, 0x0e,
	0x1b, 0x2a, 0x71, 0x99, 0xc5, 0xde, 0xdb, 0xc2, 0x50, 0x6a, 0xab, 0xbb, 0x9d, 0xf7, 0xc1, 0x96,
	0x62, 0x55, 0x1b, 0x37, 0x64, 0x42, 0xf5, 0x35, 0xc5, 0x4a, 0x5b, 0x55, 0x94, 0x5d, 0xbd, 0x5b,
	0x0b, 0xa0, 0x5c, 0xf7, 0x8f, 0xc4, 0xc8, 0x7b, 0x39, 0xcb, 0xe3, 0x92, 0x18, 0xf9, 0x1b, 0x19,
	0x4b, 0x1b, 0xcb, 0xe2, 0x10, 0x27, 0x9f, 0x79, 0x46, 0x85, 0xe6, 0x76, 0x04, 0xf2, 0x97, 0x3a,
	0x45, 0x0e, 0x61, 0x5b, 0x42, 0xaa, 0xe6, 0x9b, 0xad, 0xb6, 0x25, 0x90, 0x57, 0x8d, 0x77, 0x0f,
	0x24, 0xef, 0x6c, 0xc6, 0x35, 0x85, 0x58, 0x17, 0xc8, 0xd5, 0x88, 0x4f, 0x61, 0x3b, 0x44, 0x91,
	0xf2, 0x44, 0xa0, 0x9e, 0x54, 0x4a, 0x59, 0xd8, 0xce, 0x8c, 0x6b, 0x1b, 0x1b, 0x51, 0xef, 0x18,
	0xec, 0x10, 0x3f, 0x8e, 0x51, 0xe4, 0xdd, 0xce, 0x3c, 0xec, 0x7d, 0x68, 0x18, 0x76, 0xb2, 0x03,
	0xf5, 0x91, 0x18, 0x28, 0x8c, 0x1d, 0xca, 0x4f, 0x6f, 0x03, 0x40, 0x33, 0xb5, 0xe3, 0xd8, 0x7b,
	0x07, 0xd0, 0x8e, 0x63, 0x33, 0x44, 0xc5, 0xa9, 0x2c, 0xb9, 0xe2, 0xae, 0xb5, 0x8c, 0x53, 0xe5,
	0xef, 0x42, 0xe1, 0x54, 0x19, 0x9c, 0xdc, 0xae, 0x82, 0x73, 0x71, 0xcd, 0x53, 0x43, 0xff, 0x01,
	0xa0, 0x4d, 0xa9, 0x89, 0x96, 0xa0, 0xdd, 0x0b, 0xe6, 0x60, 0xef, 0xa8, 0xe9, 0xd5, 0x08, 0x83,
	0xed, 0xe7, 0x2c, 0x31, 0xcd, 0x4e, 0x27, 0xdd, 0x0e, 0xf1, 0xe7, 0x92, 0x68, 0x81, 0xf7, 0x96,
	0x18, 0xcd, 0xab, 0x91, 0x2b, 0xd8, 0xbc, 0x4c, 0x69, 0x3f, 0xc7, 0x7f, 0xd9, 0xec, 0x70, 0xc1,
	0xcd, 0xbc, 0x1a, 0xb9, 0x86, 0xdd, 0x0e, 0xc6, 0x58, 0xf4, 0x59, 0x72, 0xa9, 0xa5, 0x3a, 0x6d,
	0x49, 0xf1, 0x2a, 0xce, 0x38, 0x5a, 0xac, 0x4d, 0x3b, 0x8e, 0xf7, 0xe6, 0x41, 0x4b, 0x56, 0xaf,
	0x76, 0xba, 0xf3, 0x75, 0xda, 0xb4, 0xbe, 0x4d, 0x9b, 0xd6, 0x8f, 0x69, 0xd3, 0xfa, 0xf2, 0xb3,
	0x59, 0x7b, 0xbf, 0xa6, 0xfe, 0x8f, 0x9e, 0xfd, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x87, 0x28, 0x9d,
	0x0d, 0xa4, 0x06, 0x00, 0x00,
}

func (m *ProductInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProductSeo != nil {
		{
			size, err := m.ProductSeo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintShopproduct(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ProductSize) > 0 {
		for iNdEx := len(m.ProductSize) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProductSize[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShopproduct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ProductImage) > 0 {
		for iNdEx := len(m.ProductImage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProductImage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShopproduct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.ProductCategoryId != 0 {
		i = encodeVarintShopproduct(dAtA, i, uint64(m.ProductCategoryId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ProductDescription) > 0 {
		i -= len(m.ProductDescription)
		copy(dAtA[i:], m.ProductDescription)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.ProductDescription)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ProductPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ProductPrice))))
		i--
		dAtA[i] = 0x21
	}
	if len(m.ProductSku) > 0 {
		i -= len(m.ProductSku)
		copy(dAtA[i:], m.ProductSku)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.ProductSku)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProductName) > 0 {
		i -= len(m.ProductName)
		copy(dAtA[i:], m.ProductName)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.ProductName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShopproduct(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProductImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ImageUrl) > 0 {
		i -= len(m.ImageUrl)
		copy(dAtA[i:], m.ImageUrl)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.ImageUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ImageCode) > 0 {
		i -= len(m.ImageCode)
		copy(dAtA[i:], m.ImageCode)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.ImageCode)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ImageName) > 0 {
		i -= len(m.ImageName)
		copy(dAtA[i:], m.ImageName)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.ImageName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShopproduct(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProductSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SizeCode) > 0 {
		i -= len(m.SizeCode)
		copy(dAtA[i:], m.SizeCode)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.SizeCode)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SizeName) > 0 {
		i -= len(m.SizeName)
		copy(dAtA[i:], m.SizeName)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.SizeName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShopproduct(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProductSeo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProductSeo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProductSeo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SeoCode) > 0 {
		i -= len(m.SeoCode)
		copy(dAtA[i:], m.SeoCode)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.SeoCode)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SeoDescription) > 0 {
		i -= len(m.SeoDescription)
		copy(dAtA[i:], m.SeoDescription)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.SeoDescription)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SeoKeywords) > 0 {
		i -= len(m.SeoKeywords)
		copy(dAtA[i:], m.SeoKeywords)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.SeoKeywords)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SeoTitle) > 0 {
		i -= len(m.SeoTitle)
		copy(dAtA[i:], m.SeoTitle)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.SeoTitle)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintShopproduct(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseProduct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseProduct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseProduct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProductId != 0 {
		i = encodeVarintShopproduct(dAtA, i, uint64(m.ProductId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProductId != 0 {
		i = encodeVarintShopproduct(dAtA, i, uint64(m.ProductId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintShopproduct(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestAll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AllProduct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllProduct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllProduct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProductInfo) > 0 {
		for iNdEx := len(m.ProductInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProductInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintShopproduct(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintShopproduct(dAtA []byte, offset int, v uint64) int {
	offset -= sovShopproduct(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProductInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShopproduct(uint64(m.Id))
	}
	l = len(m.ProductName)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	l = len(m.ProductSku)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	if m.ProductPrice != 0 {
		n += 9
	}
	l = len(m.ProductDescription)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	if m.ProductCategoryId != 0 {
		n += 1 + sovShopproduct(uint64(m.ProductCategoryId))
	}
	if len(m.ProductImage) > 0 {
		for _, e := range m.ProductImage {
			l = e.Size()
			n += 1 + l + sovShopproduct(uint64(l))
		}
	}
	if len(m.ProductSize) > 0 {
		for _, e := range m.ProductSize {
			l = e.Size()
			n += 1 + l + sovShopproduct(uint64(l))
		}
	}
	if m.ProductSeo != nil {
		l = m.ProductSeo.Size()
		n += 1 + l + sovShopproduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShopproduct(uint64(m.Id))
	}
	l = len(m.ImageName)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	l = len(m.ImageCode)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	l = len(m.ImageUrl)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShopproduct(uint64(m.Id))
	}
	l = len(m.SizeName)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	l = len(m.SizeCode)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProductSeo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovShopproduct(uint64(m.Id))
	}
	l = len(m.SeoTitle)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	l = len(m.SeoKeywords)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	l = len(m.SeoDescription)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	l = len(m.SeoCode)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseProduct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovShopproduct(uint64(m.ProductId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProductId != 0 {
		n += 1 + sovShopproduct(uint64(m.ProductId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovShopproduct(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllProduct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ProductInfo) > 0 {
		for _, e := range m.ProductInfo {
			l = e.Size()
			n += 1 + l + sovShopproduct(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovShopproduct(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozShopproduct(x uint64) (n int) {
	return sovShopproduct(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ProductInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShopproduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSku", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductSku = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ProductPrice = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductCategoryId", wireType)
			}
			m.ProductCategoryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductCategoryId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductImage = append(m.ProductImage, &ProductImage{})
			if err := m.ProductImage[len(m.ProductImage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductSize = append(m.ProductSize, &ProductSize{})
			if err := m.ProductSize[len(m.ProductSize)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductSeo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProductSeo == nil {
				m.ProductSeo = &ProductSeo{}
			}
			if err := m.ProductSeo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShopproduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShopproduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShopproduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShopproduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShopproduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShopproduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SizeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SizeCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShopproduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShopproduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProductSeo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShopproduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProductSeo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProductSeo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoKeywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoKeywords = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeoCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeoCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShopproduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShopproduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseProduct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShopproduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseProduct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseProduct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShopproduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShopproduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShopproduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductId", wireType)
			}
			m.ProductId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProductId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShopproduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShopproduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShopproduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShopproduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShopproduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestAll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShopproduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestAll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestAll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipShopproduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShopproduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllProduct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShopproduct
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllProduct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllProduct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShopproduct
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthShopproduct
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductInfo = append(m.ProductInfo, &ProductInfo{})
			if err := m.ProductInfo[len(m.ProductInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShopproduct(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthShopproduct
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShopproduct(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShopproduct
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShopproduct
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthShopproduct
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupShopproduct
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthShopproduct
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthShopproduct        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShopproduct          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupShopproduct = fmt.Errorf("proto: unexpected end of group")
)
